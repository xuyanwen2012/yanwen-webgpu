<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Hello World</title>
</head>

<body>
    <pre id="output"></pre>

    <script>
        function log(...args) {
            document.getElementById("output").textContent += args.join(" ") + "\n";
        }

        async function init() {
            if (!navigator.gpu) {
                throw Error("WebGPU not supported.");
            }

            const adapter = await navigator.gpu.requestAdapter({
                powerPreference: "high-performance",
                forceFallbackAdapter: false
            });
            if (!adapter) {
                throw Error("Couldn't request WebGPU adapter.");
            }

            // const info = await adapter.requestAdapterInfo();
            // console.log(info);

            const device = await adapter.requestDevice();

            console.log(device);
        }

        async function main() {
            log("Hello World");

            await init();



            const N = navigator.hardwareConcurrency || 4;     // number of workers

            log("Number of workers: " + N);

            const data = new Float32Array(10_000_000).map((_, i) => i);

            // Create a worker from a blob (so we keep one file for demo)
            const workerSrc = `
self.onmessage = (e) => {
  const { buf, start, end } = e.data;
  const arr = new Float32Array(buf, start * 4, end - start);
  // expensive transform: y = sqrt(x + 1)
  for (let i = 0; i < arr.length; i++) arr[i] = Math.sqrt(arr[i] + 1);
  // just signal done (we modified the shared buffer region)
  self.postMessage({ start, end });
};`;
            const workerURL = URL.createObjectURL(new Blob([workerSrc], { type: "text/javascript" }));

            // Use a SharedArrayBuffer so workers write in-place without copying
            // NOTE: requires cross-origin isolation headers (COOP/COEP) in production.
            const sab = new SharedArrayBuffer(data.byteLength);
            const shared = new Float32Array(sab);
            shared.set(data);

            const chunk = Math.ceil(shared.length / N);
            let done = 0;

            for (let w = 0; w < N; w++) {
                const start = w * chunk;
                const end = Math.min(shared.length, start + chunk);
                if (start >= end) break;

                const worker = new Worker(workerURL);
                worker.onmessage = () => {
                    worker.terminate();
                    if (++done === Math.ceil(shared.length / chunk)) {
                        console.log("done", shared); // results are in `shared`
                    }
                };
                worker.postMessage({ buf: sab, start, end });
            }

        }

        main();
    </script>
</body>

</html>