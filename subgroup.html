<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebGPU Subgroup Matrix</title>
</head>

<body>
    <pre id="output"></pre>

    <script>
        function log(...args) {
            document.getElementById('output').textContent += args.join(' ') + '\n';
        }

        async function run(device) {
            // Minimal compute shader using f16
            const computeShader = `
                enable chromium_experimental_subgroup_matrix;
                enable f16;

                @group(0) @binding(0) var<storage, read>        A : array<f16>;
                @group(0) @binding(1) var<storage, read>        B : array<f16>;
                @group(0) @binding(2) var<storage, read_write>  C : array<f16>;

                @compute @workgroup_size(64, 1, 1)
                fn main(@builtin(global_invocation_id) gid : vec3<u32>, @builtin(subgroup_id) sid : u32) {
                   let index = gid.x;

                   var a_left : subgroup_matrix_left<f16, 8, 8>;
                   var a_right : subgroup_matrix_right<f16, 8, 8>;
                   var a_result : subgroup_matrix_result<f16, 8, 8>;

                   a_result = subgroupMatrixMultiply<f16>(a_left, a_right);

                    let a0 : f16 = A[0];
                    let b0 : f16 = B[0];
                    C[0] = 99.0h;
                    
                }
            `;

            log(computeShader);

            const A = new Float16Array(8 * 8);
            const B = new Float16Array(8 * 8);
            const C = new Float16Array(8 * 8);

            for (let i = 0; i < 8 * 8; i++) {
                A[i] = 1.0;
                B[i] = 1.0;
                C[i] = 0.0;
            }

            const A_Buffer = device.createBuffer({
                size: A.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });

            const B_Buffer = device.createBuffer({
                size: B.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });

            const C_Buffer = device.createBuffer({
                size: C.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });

            // Create staging buffer for reading results
            const stagingBuffer = device.createBuffer({
                size: C.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            });

            device.queue.writeBuffer(A_Buffer, 0, A);
            device.queue.writeBuffer(B_Buffer, 0, B);



            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: device.createShaderModule({
                        code: computeShader
                    }),
                    entryPoint: 'main'
                }
            });

            // Create bind group

            const bindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: { buffer: A_Buffer }
                    },
                    {
                        binding: 1,
                        resource: { buffer: B_Buffer }
                    },
                    {
                        binding: 2,
                        resource: { buffer: C_Buffer }
                    }
                ]
            });

            // Create command encoder and compute pass
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);

            // Dispatch the compute shader 
            computePass.dispatchWorkgroups(1);
            computePass.end();

            // Copy output to staging buffer for reading
            commandEncoder.copyBufferToBuffer(C_Buffer, 0, stagingBuffer, 0, C.byteLength);

            // Submit and wait for GPU execution
            const commandBuffer = commandEncoder.finish();
            device.queue.submit([commandBuffer]);

            // Wait for GPU to finish
            await device.queue.onSubmittedWorkDone();

            log('Compute shader executed successfully on GPU!');

            // Map and read the results
            await stagingBuffer.mapAsync(GPUMapMode.READ);
            const results = new Float16Array(stagingBuffer.getMappedRange());
            
            // Copy the data before unmapping to avoid detached ArrayBuffer
            const resultsCopy = new Float16Array(results);
            stagingBuffer.unmap();

            log('Results: ' + resultsCopy);


        }

        async function main() {
            if (!navigator.gpu?.requestAdapter) {
                log('WebGPU is NOT available in this browser.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                log('No GPU adapter found.');
                return;
            }

            log('Adapter found: ' + (adapter.info.description || 'Unnamed GPU'));

            const requiredFeatures = [
                'chromium-experimental-subgroup-matrix',
                'shader-f16'
            ];

            if (!requiredFeatures.every(f => adapter.features.has(f))) {
                log('Missing required features:', requiredFeatures.join(', '));
                return;
            }

            const device = await adapter.requestDevice({ requiredFeatures });
            log('Running...');
            await run(device);
        }

        main();
    </script>
</body>

</html>