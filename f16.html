<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>WebGPU Shader-F16 Check</title>
</head>

<body>
    <pre id="output"></pre>

    <script>
        function log(...args) {
            document.getElementById('output').textContent += args.join(' ') + '\n';
        }

        async function computeF16(device) {
            // Minimal compute shader using f16
            const computeShader = `
                enable f16;

                const M : u32 = 1024u;
                const N : u32 = 1024u;
                const K : u32 = 1024u;

                @group(0) @binding(0) var<storage, read>        A : array<f16>; // len = M*K
                @group(0) @binding(1) var<storage, read>        B : array<f16>; // len = K*N
                @group(0) @binding(2) var<storage, read_write>  C : array<f16>; // len = M*N

                @compute @workgroup_size(16, 16, 1)
                fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
                    // Each thread computes one C[row, col]
                    let row = gid.y;  // 0..1023
                    let col = gid.x;  // 0..1023

                    // No bounds checks needed because we will dispatch exactly 1024/16 = 64 groups.
                    var sum : f16 = 0.0h;
                    for (var k : u32 = 0u; k < K; k = k + 1u) {
                        let a = A[row * K + k];
                        let b = B[k * N + col];
                        sum = sum + a * b;
                    }
                    C[row * N + col] = sum;
                }
            `;

            log(computeShader);

            // Create input and output buffers
            const M = 1024;
            const N = 1024;
            const K = 1024;

            const A = new Float16Array(M * K);
            const B = new Float16Array(K * N);
            const C = new Float16Array(M * N);

            // Initialize matrices with some test data
            for (let i = 0; i < M * K; i++) {
                A[i] = Math.random() * 2 - 1; // Random values between -1 and 1
            }

            for (let i = 0; i < K * N; i++) {
                B[i] = Math.random() * 2 - 1; // Random values between -1 and 1
            }

            for (let i = 0; i < M * N; i++) {
                C[i] = 0;
            }

            // peek first 10 elements of A, B, C
            // log('Matrix A (first 10 elements):', A.slice(0, 10));
            // log('Matrix B (first 10 elements):', B.slice(0, 10));
            // log('Matrix C (first 10 elements):', C.slice(0, 10));

            const A_Buffer = device.createBuffer({
                size: A.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });

            const B_Buffer = device.createBuffer({
                size: B.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });

            const C_Buffer = device.createBuffer({
                size: C.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });

            // Create staging buffer for reading results
            const stagingBuffer = device.createBuffer({
                size: C.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            });

            // Upload input data
            device.queue.writeBuffer(A_Buffer, 0, A);
            device.queue.writeBuffer(B_Buffer, 0, B);

            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: device.createShaderModule({
                        code: computeShader
                    }),
                    entryPoint: 'main'
                }
            });

            // Create bind group
            const bindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: { buffer: A_Buffer }
                    },
                    {
                        binding: 1,
                        resource: { buffer: B_Buffer }
                    },
                    {
                        binding: 2,
                        resource: { buffer: C_Buffer }
                    }
                ]
            });

            // Create command encoder and compute pass
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);

            // Dispatch the compute shader (64x64 workgroups for 1024x1024 matrix)
            computePass.dispatchWorkgroups(64, 64);
            computePass.end();

            // Copy output to staging buffer for reading
            commandEncoder.copyBufferToBuffer(C_Buffer, 0, stagingBuffer, 0, C.byteLength);

            // Submit and wait for GPU execution
            const commandBuffer = commandEncoder.finish();
            device.queue.submit([commandBuffer]);

            // Wait for GPU to finish
            await device.queue.onSubmittedWorkDone();

            // Map and read the results
            await stagingBuffer.mapAsync(GPUMapMode.READ);
            const results = new Float16Array(stagingBuffer.getMappedRange());
            // Copy the data before unmapping to avoid detached ArrayBuffer
            const resultsCopy = new Float16Array(results);
            stagingBuffer.unmap();



            // Display results
            log('Matrix multiplication completed!');
            log('Result matrix C (first 10 elements):', resultsCopy.slice(0, 10));

            // Show some sample results from different positions
            log('C[0,0] =', resultsCopy[0]);
            log('C[0,1] =', resultsCopy[1]);
            log('C[1,0] =', resultsCopy[1024]);
            log('C[1,1] =', resultsCopy[1025]);
            log('C[100,100] =', resultsCopy[100 * 1024 + 100]);

            // Verify a few results manually
            let manualCheck = 0;
            for (let k = 0; k < 10; k++) {
                manualCheck += A[k] * B[k * 1024];
            }
            log('Manual verification C[0,0] =', manualCheck);
            log('GPU result C[0,0] =', resultsCopy[0]);

            // Also log to console for debugging
            log('F16 Results:', resultsCopy);
            log('Matrix A:', A);
            log('Matrix B:', B);

            log('Compute shader executed successfully on GPU!');
        }

        async function main() {
            if (!navigator.gpu?.requestAdapter) {
                log('WebGPU is NOT available in this browser.');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                log('No GPU adapter found.');
                return;
            }

            log('Adapter found: ' + (adapter.info.description || 'Unnamed GPU'));

            // Check if shader-f16 is supported
            if (adapter.features.has('shader-f16')) {
                log('shader-f16 is supported');

                // Create device with shader-f16 feature
                const device = await adapter.requestDevice({
                    requiredFeatures: ['shader-f16']
                });

                // Run the f16 compute shader
                await computeF16(device);

            } else {
                log('shader-f16 is NOT supported');
            }
        }

        main();
    </script>
</body>

</html>