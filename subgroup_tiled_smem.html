<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>WebGPU Subgroup Matrix</title>
</head>

<body>
    <pre id="output"></pre>

    <script>
        function log(...args) {
            document.getElementById("output").textContent += args.join(" ") + "\n";
        }

        function printMatrix(A, rows, cols, verbose = false) {
            if (verbose) {
                // Print full matrix
                for (let i = 0; i < rows; i++) {
                    let row = [];
                    for (let j = 0; j < cols; j++) {
                        row.push(A[i * cols + j]);
                    }
                    log(row.join(" "));
                }
            } else {
                // Print abbreviated matrix with ellipsis
                for (let i = 0; i < rows; i++) {
                    if (i < 3 || i > rows - 4) {
                        let row = [];
                        for (let j = 0; j < cols; j++) {
                            if (j < 3 || j > cols - 4) {
                                row.push(A[i * cols + j]);
                            } else if (j === 3) {
                                row.push("...");
                            }
                        }
                        log(row.join(" "));
                    } else if (i === 3) {
                        log("...");
                    }
                }
            }
        }

        function cpuImplementation(A, B, C, matrix_size) {
            let start = performance.now();

            for (let i = 0; i < matrix_size; i++) {
                for (let j = 0; j < matrix_size; j++) {
                    C[i * matrix_size + j] = 0;
                    for (let k = 0; k < matrix_size; k++) {
                        C[i * matrix_size + j] += A[i * matrix_size + k] * B[k * matrix_size + j];
                    }
                }
            }

            let end = performance.now();

            log("\nCPU Took: " + (end - start) + "ms");

            printMatrix(C, matrix_size, matrix_size);
            return C;
        }

        function calculateMSE(cpuResult, gpuResult, size) {
            let mse = 0;
            let numElements = size * size;

            for (let i = 0; i < numElements; i++) {
                let error = cpuResult[i] - gpuResult[i];
                mse += error * error;
            }

            mse /= numElements;
            return mse;
        }

        async function run(device) {
            // We assume square matrix for now

            // N = number of columns/rows in the full matrix (your stride)
            // e.g.,
            // A,B are 16x16, then N = 16
            // A(M, K) matrix multiply B(K, N) = C(M, N)
            // Also known as "M, N, K = 16, 16, 16"

            // TILE_SIZE = hardware specific in X/Y direction
            // e.g.,
            // TILE_SIZE = 8, Apple M4
            // Also known as "TENSOR_M, TENSOR_N, TENSOR_K = 8, 8, 8"

            // in above example,
            // our tile_row will iterate from 0 to 1 (two tiles in Y)
            // our tile_col will iterate from 0 to 1 (two tiles in X)

            // offsets should be (tile_row * N * TILE_SIZE) + (tile_col * TILE_SIZE);
            // tile(0, 0) = 0 * 16 * 8 + 0 * 8 = 0
            // tile(0, 1) = 0 * 16 * 8 + 1 * 8 = 8
            // tile(1, 0) = 1 * 16 * 8 + 0 * 8 = 128
            // tile(1, 1) = 1 * 16 * 8 + 1 * 8 = 136

            const computeShader = `
                enable chromium_experimental_subgroup_matrix;
                enable f16;

                @group(0) @binding(0) var<storage, read>        A : array<f16>;
                @group(0) @binding(1) var<storage, read>        B : array<f16>;
                @group(0) @binding(2) var<storage, read_write>  C : array<f16>;

                
                const MAT_SIZE : u32 = 64u;
                const TILE_SIZE : u32 = 8u;
                const NUM_TILES : u32 = 8u; // how many tiles 

                const kColMajor : bool = false;  
                // const kStride   : u32  = 64u;     

                @compute @workgroup_size(64, 1, 1) 
                fn main(
                    @builtin(workgroup_id)  wg_id : vec3<u32>,
                    @builtin(subgroup_id)  sid  : u32,
                ) {
                    let tile_col : u32 = wg_id.x % NUM_TILES; 
                    let tile_row : u32 = wg_id.x / NUM_TILES; 
                    
                    if (wg_id.x >= NUM_TILES * NUM_TILES) {
                        return;
                    }


                    var ACC : subgroup_matrix_result<f16, 8, 8>;


                    for (var k_tile = 0u; k_tile < NUM_TILES; k_tile++) {
                        let a_offset = u32(tile_row * MAT_SIZE + k_tile * TILE_SIZE);
                        let b_offset = u32(k_tile * MAT_SIZE + tile_col * TILE_SIZE);

                        let L = subgroupMatrixLoad<subgroup_matrix_left<f16, 8, 8>>(&A, a_offset, kColMajor, MAT_SIZE);
                        let R = subgroupMatrixLoad<subgroup_matrix_right<f16, 8, 8>>(&B, b_offset, kColMajor, MAT_SIZE);

                        ACC = subgroupMatrixMultiplyAccumulate(L, R, ACC);
                    }

                    let c_offset : u32 = (tile_row * TILE_SIZE) * MAT_SIZE + (tile_col * TILE_SIZE);
                    subgroupMatrixStore(&C, c_offset, ACC, kColMajor, MAT_SIZE);

                    // let tmp = A[0];
                    // let tmp2 = B[0];
                    // let tmp3 = C[0];
                }
            `;

            log(computeShader);

            // if each tile is 8x8, then
            const MAT_SIZE = 64;

            const A = new Float16Array(MAT_SIZE * MAT_SIZE); // 2 tiles in X, 2 tiles in Y
            const B = new Float16Array(MAT_SIZE * MAT_SIZE); // 2 tiles in X, 2 tiles in Y
            const C = new Float16Array(MAT_SIZE * MAT_SIZE); // 2 tiles in X, 2 tiles in Y

            for (let i = 0; i < MAT_SIZE * MAT_SIZE; i++) {
                A[i] = Math.random() / 10.0;
                // A[i] = 1.0;
            }

            for (let i = 0; i < MAT_SIZE * MAT_SIZE; i++) {
                const row = Math.floor(i / MAT_SIZE);
                const col = i % MAT_SIZE;
                B[i] = (row === col) ? 1.0 : 0.0;
            }

            for (let i = 0; i < MAT_SIZE * MAT_SIZE; i++) {
                C[i] = 0;
            }

            const A_Buffer = device.createBuffer({
                size: A.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });

            const B_Buffer = device.createBuffer({
                size: B.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });

            const C_Buffer = device.createBuffer({
                size: C.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });

            // Create staging buffer for reading results
            const stagingBuffer = device.createBuffer({
                size: C.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            });

            device.queue.writeBuffer(A_Buffer, 0, A);
            device.queue.writeBuffer(B_Buffer, 0, B);

            // Create compute pipeline
            const computePipeline = device.createComputePipeline({
                layout: "auto",
                compute: {
                    module: device.createShaderModule({
                        code: computeShader,
                    }),
                    entryPoint: "main",
                },
            });

            // Create bind group

            const bindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    {
                        binding: 0,
                        resource: { buffer: A_Buffer },
                    },
                    {
                        binding: 1,
                        resource: { buffer: B_Buffer },
                    },
                    {
                        binding: 2,
                        resource: { buffer: C_Buffer },
                    },
                ],
            });

            // Warmup: Run the kernel once without timing
            log("Warming up GPU kernel...");
            const warmupCommandEncoder = device.createCommandEncoder();
            const warmupComputePass = warmupCommandEncoder.beginComputePass();
            warmupComputePass.setPipeline(computePipeline);
            warmupComputePass.setBindGroup(0, bindGroup);
            warmupComputePass.dispatchWorkgroups(64);
            warmupComputePass.end();

            const warmupCommandBuffer = warmupCommandEncoder.finish();
            device.queue.submit([warmupCommandBuffer]);
            await device.queue.onSubmittedWorkDone();
            log("Warmup completed.");

            // Now run the actual timed execution
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);

            // Dispatch the compute shader
            // For 64x64 matrix with 8x8 tiles, we need 8*8 = 64 workgroups
            computePass.dispatchWorkgroups(64);
            computePass.end();

            // Copy output to staging buffer for reading
            commandEncoder.copyBufferToBuffer(
                C_Buffer,
                0,
                stagingBuffer,
                0,
                C.byteLength,
            );

            // Submit and wait for GPU execution
            const commandBuffer = commandEncoder.finish();
            device.queue.submit([commandBuffer]);

            let start = performance.now();

            await device.queue.onSubmittedWorkDone();

            let end = performance.now();

            log(
                "\nCompute shader executed successfully on GPU! " +
                (end - start) +
                "ms",
            );

            // Map and read the results
            await stagingBuffer.mapAsync(GPUMapMode.READ);
            const results = new Float16Array(stagingBuffer.getMappedRange());

            // Copy the data before unmapping to avoid detached ArrayBuffer
            const resultsCopy = new Float16Array(results);
            stagingBuffer.unmap();

            printMatrix(resultsCopy, MAT_SIZE, MAT_SIZE);

            // Run CPU implementation and get results
            const cpuResult = new Float16Array(MAT_SIZE * MAT_SIZE);
            cpuImplementation(A, B, cpuResult, MAT_SIZE);

            // Calculate Mean Square Error
            const mse = calculateMSE(cpuResult, resultsCopy, MAT_SIZE);
            log("\n=== COMPARISON RESULTS ===");
            log("Mean Square Error (MSE):", mse.toFixed(8));
            log("Root Mean Square Error (RMSE):", Math.sqrt(mse).toFixed(8));
            log("================================\n");
        }

        async function main() {
            if (!navigator.gpu?.requestAdapter) {
                log("WebGPU is NOT available in this browser.");
                return;
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                log("No GPU adapter found.");
                return;
            }

            log("Adapter found: " + (adapter.info.description || "Unnamed GPU"));

            const requiredFeatures = [
                "chromium-experimental-subgroup-matrix",
                "shader-f16",
            ];

            if (!requiredFeatures.every((f) => adapter.features.has(f))) {
                log("Missing required features:", requiredFeatures.join(", "));
                return;
            }

            const device = await adapter.requestDevice({ requiredFeatures });
            log("Running...");
            await run(device);
        }

        main();
    </script>
</body>

</html>